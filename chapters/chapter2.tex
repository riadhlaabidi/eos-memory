\chapter{Sprint 0: Requirements gathering and Specification}

\phantomsection
\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}
In this chapter, we place significant focus on gathering requirements and transforming them
into well-defined and documented specifications. This includes creating use cases and user stories,
which provide valuable insights into system interactions and user workflows. Furthermore, we establish
a prioritized product backlog, ensuring efficient resource allocation and timely delivery of the most
critical and valuable features.

\section{Requirements gathering}
By conducting a comprehensive analysis of the requirements, we aim to bridge the gap between
the stakeholders' vision and the actual implementation of the product or system.
This analysis helps us define clear and concise specifications that serve as the foundation for the design,
development, and testing phases of the project.

\subsection{Identifying end-users}
Identifying end-users is a crucial step in requirements analysis as it helps determine the needs,
expectations, and constraints of the target audience. In our application, we were able to identify
three types of actors:

\begin{itemize}
      \item \textbf{Administrator}: Is responsible for overseeing user accounts, configuring and maintaining the
            resources needed by agents or employees to ensure the smooth operation of the system inside the organization.

      \item \textbf{Agent}: Is an employee inside the organization in charge of executing actions on the
            notification center: creating and scheduling notification campaigns including the creation of
            notification content, client base segmentation.

      \item \textbf{Client}: Is a customer who is going to be targeted by notifications from the business
            or organization they belong to. A customer should be able to receive notifications and set their
            preferences for receiving notifications from that business.
\end{itemize}

\subsection{Functional requirements}
\label{freq}
Functional requirements define the specific actions, tasks, and behaviors that the product
must be able to perform in order to meet the needs of its end-users. These requirements
form the foundation of the system's functionality.

\noindent The functional requirements we captured for each actor are outlined below.

\paragraph*{Authentication and Profile settings}
\label{common-req}
\begin{itemize}
      \item \textbf{Sign in:} A registered user should be able to access the system by providing
            valid credentials.
      \item \textbf{Edit profile settings:} A logged in user should be able to edit his profile settings.
      \item \textbf{View statistics:} A logged in user should be able to view notification activity metrics
            on his dashboard.
\end{itemize}
\raggedbottom


\paragraph*{Administrator requirements}
\label{admin-req}
\begin{itemize}
      \item \textbf{Manage agents:} An administrator should be able to add new agents, update,
            delete, desactivate accounts and reset passwords for existing agents.
      \item \textbf{Manage channels:} An administrator should be able to create new notification channels,
            update, delete, configure service providers for existing channels.
      \item \textbf{Manage topics:} An administrator should be able to create new notification topics,
            update, delete and configure topic's priority for existing ones.
\end{itemize}


\paragraph*{Agent requirements}
\label{agent-req}
\begin{itemize}
      \item \textbf{Manage templates:} An agent should be able to create new notification templates, update and
            delete existing ones.
      \item \textbf{Manage triggers:} An agent should be able to create new notification triggers, configure
            the target audience the scheduling, update, change status and delete existing triggers.
      \item \textbf{Manage audiences:} An agent should be able create new segments of users based on a
            criteria, update and delete existing ones.
      \item \textbf{View logs:} An agent should be able to view logs of sent notifications and their statuses.
\end{itemize}

\paragraph*{Client requirements}
\label{client-req}
\begin{itemize}
      \item \textbf{Manage notification preference:} A client should be able to edit his notification preferences,
            channels and frequency of receiving notifications.
      \item \textbf{View notification history:} A client should be able to checkout a history of his received
            notifications (for in-app notifications).
\end{itemize}


\section{Scrum implementation overview}
\label{spec}
This section provides an overview of the Scrum implementation in our project It includes a global use case diagram, showcasing the system's
high-level functionalities, followed by the presentation of the product backlog and the planning
of the sprints.

\subsection{Global use case diagram}
Using \acrshort{uml} use case diagrams to model the requirements allows for a visual representation
of the interactions between actors and the system, providing a clear and concise way to specify
the functionalities and behaviors expected from the product.

Clients, acting as the base, can customize notification preferences and access their notification history.
Agents, inheriting from clients, extend functionalities to include managing templates, triggers, audiences,
and logs. Administrators, inheriting from agents, further enhance their capabilities to manage agents,
channels, and topics. Agents and Administrators can sign in, edit profiles, and view statistics.

\noindent The figure \ref{g-usecase} illustrates the global use case diagram we modeled for our notification system.

\begin{figure}[hbt!]
      \centering
      \includesvg[width=0.9\textwidth]{diagrams/usecase/usecase}
      \caption{Notification Center global use case diagram}
      \label{g-usecase}
\end{figure}

\newpage

\subsection{Product backlog}
The Product Backlog serves as a dynamic and living artifact that captures and organizes the
ever-evolving list of features, functionalities, and enhancements desired for a software product.

\begin{itemize}
      \item \textbf{Epic:} Is a large body of work that can be broken down into a number of smaller stories.
      \item \textbf{User story:} Is an informal, general explanation of a software feature written from the
            perspective of the end user or customer, in the form of: \\ “As a [persona], I [want to], [so that].” \\
\end{itemize}

\noindent The table \ref{tab-backlog} represents our product backlog.

\begin{longtable}{ | m{0.18\textwidth}  | m{0.77\textwidth} | }
      \caption{Product backlog} \label{tab-backlog}                                                                                                                                                                                                           \\
      \hline
      \textbf{Epic}                                           & \textbf{User story}                                                                                                                                                                           \\
      \hline
      \endfirsthead
      \hline
      \textbf{Epic}                                           & \textbf{User story}                                                                                                                                                                           \\
      \hline
      \endhead
      \hline
      \endfoot
      \endlastfoot
      Authentication                                          & \textbf{Authenticate}: As a registered user, I want to be able to log into my account securely using my email and password.                                                                   \\
      \hline
      \multirow[t]{4}{5em}{Agents management}                 & \textbf{Create an agent}: As an administrator, I want to be able to create agents so that I can add them to the notification center.                                                          \\
      \cline{2-2}
                                                              & \textbf{List agents}: As an administrator, I want to be able to list agents so that I can view all registered agents.                                                                         \\
      \cline{2-2}
                                                              & \textbf{Edit an agent}: As an administrator, I want to be able to edit agents so that I can modify their information.                                                                         \\
      \cline{2-2}
                                                              & \textbf{Delete an agent}: As an administrator, I want to be able to delete agents so that I can get rid of no longer needed agents.                                                           \\
      \hline
      \multirow[t]{4}{5em}{Users management}                  & \textbf{Create a notification user}: As an administrator/agent, I want to be able to create users so that I can send them notifications.                                                      \\
      \cline{2-2}
                                                              & \textbf{List notification users}: As an administrator/agent, I want to be able to list users so that I can view all created users.                                                            \\
      \cline{2-2}
                                                              & \textbf{Edit a notification user}: As an administrator/agent, I want to be able to edit users so that I can modify their information.                                                         \\
      \cline{2-2}
                                                              & \textbf{Delete a notification user}: As an administrator/agent, I want to be able to delete users so that I can get rid of no longer needed users.                                            \\
      \hline
      \multirow[t]{4}{5em}{Audience management}               & \textbf{Create an audience}: As an administrator/agent, I want to be able to create an audience so that I can target specific individuals based on a criteria.                                \\
      \cline{2-2}
                                                              & \textbf{List audiences}: As an administrator/agent, I want to be able to list audiences so that I can view all created user segments.                                                         \\
      \cline{2-2}
                                                              & \textbf{Edit an audience}: As an administrator/agent, I want to be able to edit an audience so that I can change selection criteria and segment configurations.                               \\
      \cline{2-2}
                                                              & \textbf{Delete an audience}: As an administrator/agent, I want to be able to delete a group of users so that I can get rid of no longer needed groups..                                       \\
      \hline
      \multirow[t]{4}{5em}{Notification channels management}  & \textbf{Create a channel}: As an administrator/agent, I want to be able to create notification channels so that I can send notifications through these channels.                              \\
      \cline{2-2}
                                                              & \textbf{List channels}: As an administrator/agent, I want to be able to list notification channels so that I can view all created channels.                                                   \\
      \cline{2-2}
                                                              & \textbf{Edit a channel}: As an administrator, I want to be able to edit notification channels so that I can update their configurations.                                                      \\

                                                              & \textbf{Delete a channel}: As an administrator/agent, I want to be able to delete notification channels so that I can get rid of no longer used channels.                                     \\
      \hline
      \multirow[t]{4}{5em}{Notification templates management} & \textbf{Create a template}: As an agent, I want to be able to add notification templates so that I can send notifications based on that template.                                             \\
      \cline{2-2}
                                                              & \textbf{List templates}: As an agent, I want to be able to list notification templates so that I can view all created templates.                                                              \\
      \cline{2-2}
                                                              & \textbf{Edit a template}: As an agent, I want to be able to edit notification templates so that I can keep them up to date.                                                                   \\
      \cline{2-2}
                                                              & \textbf{Delete a template}: As an agent, I want to be able to delete templates so that I can get rid of no longer used templates.                                                             \\
      \hline
      Notification preferences management                     & \textbf{Set notification preferences}: As a user, I want to be able to set my notification preferences, so that I can receive notifications from the channels I want.                         \\
      \hline
      \multirow[t]{4}{5em}{Notification triggers management}  & \textbf{Create a trigger}: As an agent, I want to be able to create triggers for notifications so that I can schedule notifications to be sent automatically.                                 \\
      \cline{2-2}
                                                              & \textbf{List triggers}: As an agent, I want to be able to list triggers for notifications so that I can view all created triggers.                                                            \\
      \cline{2-2}
                                                              & \textbf{Edit a trigger}: As an agent, I want to be able to edit notifications triggers so that I can modify or update its configurations.                                                     \\
      \cline{2-2}
                                                              & \textbf{Delete a trigger}: As an agent, I want to be able to delete notification triggers so that I can get rid of outdated and no longer used triggers.                                      \\
      \hline
      \multirow[t]{4}{5em}{Notification history}              & \textbf{Get notification history}: As a user, I want to be able to list notification history so that I can review my received notifications whenever I want.                                  \\
      \cline{2-2}
                                                              & \textbf{List sending logs}: As an administrator/agent, I want to be able to list sent notification logs so that I can review all sent notifications.                                          \\
      \hline
      Dashboard                                               & \textbf{View metrics}: As an administrator/agent, I want to be able to view metrics on my dashboard so that I can get an overview on important statistics related to notification activities. \\
      \hline
\end{longtable}

\subsection{Releases and sprints planning}
A release refers to the deployment of a specific version or update of a software product. It involves meticulous planning
and coordination to ensure successful delivery.

In the table \ref{sprint-planning}, we present the detailed planning of the releases, outlining the sprints included in each release,
and the epics included in each sprint.

\begin{table}[hbt!]
      \caption{Releases and sprints planning}
      \label{sprint-planning}
      \begin{tabular}{ | m{0.25\textwidth} | m{0.25\textwidth} | m{0.42\textwidth} | }
            \hline
            \textbf{Release}                                                                             & \textbf{Sprints}            & \textbf{Epics}                      \\
            \hline
            \multirow{2}{9em}{\newline \textbf{Release 1} \newline  User, segmentation \& channels}
                                                                                                         & \multirow{3}{5em}{Sprint 1} & Authentication                      \\
            \cline{3-3}
                                                                                                         &                             & Agents management                   \\
            \cline{3-3}
                                                                                                         &                             & Users management                    \\
            \cline{2-3}

                                                                                                         & \multirow{2}{5em}{Sprint 2} & Audiences management                \\
            \cline{3-3}
                                                                                                         &                             & Notification channels management    \\
            \hline
            \multirow{2}{10em}{\newline \textbf{Release 2} \newline Sending notifications \& dashboards} & \multirow{2}{5em}{Sprint 3} & Notification templates management   \\
            \cline{3-3}
                                                                                                         &                             & Notification preferences management \\
            \cline{2-3}
                                                                                                         & \multirow{3}{5em}{Sprint 4} & Notification triggers management    \\
            \cline{3-3}
                                                                                                         &                             & Notification history                \\
            \cline{3-3}
                                                                                                         &                             & Dashboard                           \\
            \hline
      \end{tabular}
      \label{tab:planning}
\end{table}

\section{Development infrastructure}
In this section, we will discuss the development infrastructure established for the successful execution
of the project. Our primary focus will be on defining the non-functional factors that are crucial for our
product, then based on these factors, we'll proceed to discuss the software architecture, the database choice,
and the curated set of tools and frameworks that were employed to support and streamline the development workflow.

\subsection{Non-Functional requirements}
\label{nfr}
When designing a notification system, various technical requirements need to be considered to ensure
the solution's effectiveness, reliability, and scalability. Here are the key factors that we should
focus on while architecturing our system:

\begin{itemize}
      \item \textbf{Security:} The system shall enforce secure communication protocols, such as \acrshort{https},
            to protect sensitive data during transmissionn, also data and preferences stored in the system shall be securely
            encrypted to prevent unauthorized access or data breaches.
            % \item \textbf{High availability} The system should remain operational and accessible to users without
            %       significant downtime, even in the face of hardware failures, software issues, or unexpected events.
      \item \textbf{Real-time:} The system shall deliver notifications in real-time or near real-time
            to ensure timely communication, messages and notifications should be delivered with minimal delay for high
            priority topics.
      \item \textbf{Scalability:} The system should be designed to handle a high volume of concurrent users
            and notifications without compromising performance and the system architecture should be scalable, allowing for
            horizontal scaling by adding more servers or utilizing cloud-based infrastructure as the user base grows.
      \item \textbf{Customizability:} The system should provide flexibility and customizability to meet
            the specific branding and user experience requirements of different organizations. Also the system should
            allow customization of user preferences to provide a personalized experience.
\end{itemize}


\subsection{Software architecture}
To implement our notification center, we will base our work on a client-server architecture.
In this approach, the client, representing the user interface, interacts with the server, which houses
the application's core logic and data. This separation of concerns allows for centralized management
of data and business logic while catering to various clients.

One of the extensions to the mentioned architecture, and the one we will adopt is
the \textbf{three-tier monolithic architecture}, where all the application modules and components
are tightly integrated into a single codebase. This decision was based on several factors such as
the project's scope, timeline, and the team's familiarity with monolithic architectures.
Furthermore, for the envisioned requirements, a monolithic design offered simplicity and ease
of development and deployment to quickly get the application started.

\noindent The figure \ref{monolithic} illustrates the separation of the three tiers in the monolithic architecture : \\

\begin{figure}[hbt!]
      \centering
      \includesvg[width=0.85\textwidth]{app/monolithic}
      \caption{Monolithic three-tier architecture}
      \label{monolithic}
\end{figure}

\paragraph*{Presentation tier:}
The presentation tier is the user interface and communication layer of the application. Its main purpose
is to display information to users and gather information from them. This top-level tier can run on a web
browser, as desktop application, or a graphical user interface.

\paragraph*{Application tier:}
In this tier, the data collected in the presentation tier is processed, sometimes against other
information in the data tier, using business logic, a specific set of business rules. The application
tier can also add, delete or modify data in the data tier.

\paragraph*{Data tier:}
The data tier, sometimes called database tier, data access tier or back-end, is where the information
processed by the application is stored and managed. This can be a relational database management system
or a NoSQL Database server.

The user interface, business logic, and the database all reside on different machines and, thus, have
different tiers. They are physically separated.

% TODO: Illustraion if needed for components


\subsection{Technology stack and framework selection}
In this part, we will delve into the technology stack and frameworks adopted for our project.
This includes considerations for the back end, front end, and database components. By specifying
these choices, we gain a clear understanding of the tools driving the development of our project.

\subsubsection{JHipster Platform}
In our quest of identifying efficient tools to expedite the development of an enterprise-level solution,
we conducted research with a key focus on meeting the technical factors we envisioned. Our goal was to
pinpoint a solution that not only accelerates project initiation but also empowers our team to concentrate
on the core application logic while satisfying these crucial requirements.

We have reached a decision to adopt \textbf{JHipster} as the foundation for our project development.
JHipster is a development platform to quickly generate, develop, and deploy modern web applications
and microservice architectures \cite{jhipster}.

\noindent The value proposition that JHipster provides is reflected in:

\begin{itemize}
      \item The creation of fully configured applications for both the front and the back ends.
            In addition to the generation of code according to best practices and coding standards,
            ensuring a high level of code quality and consistency throughout the project.
      \item JHipster's integrated DevOps and \acrshort{cicd} capabilities provide a seamless pathway
            to automate testing, deployment, and delivery processes.
\end{itemize}

JHipster provides flexibility and options, for the back end, it primarily supports Spring Boot,
a popular Java-based framework which we discuss in detail in the following section \ref{sst}. On the front end
side, JHipster offers a variety of choices including Angular, React and Vue, we elaborate on our choice for
the front end technology in section \ref{cst}.

In conjunction with JHipster, we employed various complementary software tools to enhance
the development process (see Appendix \ref{appendix:tools}).

\subsubsection{Server-side technology}
\label{sst}
This section delves into the technology considerations for the backend part of our solution and the
employed internal architectural pattern.

\paragraph{Spring Boot framework} \mbox{} \newline \newline
\textbf{Spring Boot} emerged as the backend technology for our project.
Spring Boot is built upon the robust Spring framework, makes developing production-grade Spring based
web application and microservices faster and easier through three core capabilities:

\begin{itemize}
      \item \textbf{Auto Configuration:} Spring Boot comes with built-in autoconfiguration capabilities,
            it automatically configures both the underlying Spring Framework and third-party packages based
            on the provided settings.
      \item \textbf{Opinionated approach:}  Spring Boot chooses which packages to install and which default
            values to use, rather than requiring the developer to make all those decisions on their own and set
            up everything manually.
      \item \textbf{Standalone applications:} Spring Boot helps developers create standalone
            that run on their own, without relying on an external web server, by embedding a web server such as
            Tomcat into the application during the initialization process.
\end{itemize}

\paragraph{Spring boot flow architecture} \mbox{} \newline \newline
Spring Boot uses a hierarchical architecture in which each layer communicates with the layer immediately
below or above it as shown in the figure \ref{layers}.
\begin{figure}[hbt!]
      \centering
      \includesvg[width=0.7\textwidth]{app/spring-boot-layers}
      \caption{Spring Boot application layers}
      \label{layers}
\end{figure}

\begin{enumerate}
      \item \textbf{Presentation Layer}: The top layer of the spring boot architecture. It consists of views.
            It handles the \acrshort{http} requests and performs authentication. It is responsible for converting the \acrfull{json}
            field’s parameter to java objects and vice-versa. Once it performs the authentication of the request
            it passes it to the next layer.
      \item \textbf{Business Layer}: Contains all the business logic. It consists of multiple service classes
            and is responsible for validation and authorization.
      \item \textbf{Persistence Layer}: Implements all the database storage logic and it is responsible for
            converting business objects to the database records and vice-versa.
      \item \textbf{Database Layer}: This layer provides integration with multiple databases. It is
            responsible for performing the \acrshort{crud} operations.
\end{enumerate}

\noindent Spring Boot integrates almost all of the features and modules of the Spring framework: like Spring MVC,
Spring Core, Spring Data \& \acrshort{jpa}, etc. It follows nearly the same architectural pattern as
Spring MVC, except for one thing: there is no need for \acrfull{dao} and \acrshort{dao} Implementation
classes in Spring boot because its architecture has a data access layer and performs \acrshort{crud}
operations. \\


\begin{figure}[hbt!]
      \centering
      \includesvg[width=0.85\textwidth]{app/spring-flow}
      \caption{Spring Boot flow architecture}
      \label{flow}
\end{figure}

Controllers are the major components in Spring’s \acrshort{mvc} framework. Their primary job is to handle
\acrshort{http} requests and either hand off a request to a view to render HTML or like in our case
write data directly to the body of the response as \acrshort{json} \cite{spring-in-action}.

In order to perform business logic on data, controllers call service classes from the service layer,
which in turn inject repository classes to manipulate data in the database, and all entities are mapped
to model classes through the \acrfull{jpa}


\subsubsection{Client-side technology}
\label{cst}
This section illustrates the chosen technology for the client side of our solution and the adopted
internal architectural pattern.

\paragraph{Angular framework} \mbox{} \newline \newline
For the user facing part of our solution, we will select the \textbf{Angular} frontend framework.
Angular, developed and maintained by Google, is a development platform, built on TypeScript and
includes:
\begin{itemize}
      \item A component-based framework for building scalable web applications.
      \item A collection of well-integrated libraries that cover a wide variety of features,
            including routing, forms management, client-server communication, etc.
      \item A suite of developer tools to help develop, build, test, and update code \cite{angular}. \\
\end{itemize}


\paragraph{Angular architectural pattern} \mbox{} \newline \newline
Angular follows a component-based architectural pattern that aligns closely with the
\acrfull{mvvm} pattern, a design paradigm that separates concerns in frontend
development. While Angular's terminologies don't exactly match \acrshort{mvvm},
the concepts map as follows: \\

\begin{figure}[hbt!]
      \centering
      \includesvg[width=0.85\textwidth]{app/mvvm}
      \caption{\acrshort{mvvm} architectural pattern}
      \label{mvvm}
\end{figure}

\*{Model:} Corresponds to business logic encapsulated within services and components.
Services encapsulate data retrieval and manipulation, and act as the bridge between
the application and external data sources.

\paragraph*{View:} Corresponds to the HTML templates in Angular. Templates define the structure and
appearance of the user interface. Angular's binding mechanisms (property binding, event binding,
and two-way binding) facilitate the synchronization between the model (data) and the view (UI).

\paragraph*{ViewModel:} Is represented by the component class. The component class contains
the presentation logic, handling user interactions, processing data, and managing the application's state.
It orchestrates the communication between the model and the view, ensuring that changes in one are
reflected appropriately in the other.

\subsubsection{Database}
Selecting the appropriate database is a pivotal decision in our system design. After careful consideration,
we've chosen to employ a relational database, specifically \textbf{PostgreSQL}. This choice is driven by the
following criteria:

\begin{itemize}
      \item \textbf{Structured Data:} We need to store notification channels and templates, user segments,
            and scheduling details in structured tables, these entities share relationships that
            interconnect them.
      \item \textbf{ACID Compliance:} We need to ensure data integrity and consistency, as it's critical
            for reliable notification delivery and management.
      \item \textbf{Query Flexibility:} We need to leverage SQL queries to effectively retrieve and manipulate
            Data, enabling comprehensive reporting and analysis.
\end{itemize}

\noindent PostgreSQL is an open source object-relational database system that has a strong reputation for its
reliability, flexibility, and support of open technical standards. PostgreSQL comes with many features
aimed to help developers build applications and help managing higher data loads.

\phantomsection
\section*{Summary}
\addcontentsline{toc}{section}{Summary}
In this chapter we laid the groundwork for the project by comprehensively gathering and analyzing
the requirements. By identifying end-users, defining functional and non-functional requirements,
and creating a clear specification through use case diagrams, elaborating the product backlog, planning
sprints, specifying the application's architecture and the requisite development infrastructure, we have
set the stage for the subsequent phases of development.

The insights gained from this chapter will prove invaluable in ensuring the successful implementation
of the project and the satisfaction of the end-users. In the following chapter, we will start executing
our project providing the practical realization of the initial release.
