\chapter{Sprint 0: Requirements gathering and Specification}

\phantomsection
\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}
In this chapter, we place significant focus on gathering requirements and transforming them
into well-defined and documented specifications. This includes creating use cases and user stories,
which provide valuable insights into system interactions and user workflows. Furthermore, we establish
a prioritized product backlog, ensuring efficient resource allocation and timely delivery of the most
critical and valuable features.

\section{Requirements gathering}
By conducting a comprehensive analysis of the requirements, we aim to bridge the gap between
the stakeholders' vision and the actual implementation of the product or system.
This analysis helps us define clear and concise specifications that serve as the foundation for the design,
development, and testing phases of the project.

\subsection{Identifying end-users}
Identifying end-users is a crucial step in requirements analysis as it helps determine the needs,
expectations, and constraints of the target audience. In our application, we were able to identify
three types of actors:

\begin{itemize}
      \item \textbf{Administrator}: Is responsible for overseeing user accounts, configuring and maintaining the
            resources needed by agents or employees to ensure the smooth operation of the system inside the organization.

      \item \textbf{Agent}: Is an employee inside the organization in charge of executing actions on the
            notification center: creating and scheduling notification campaigns including the creation of
            notification content, client base segmentation.

      \item \textbf{Client}: Is a customer who is going to be targeted by notifications from the business
            or organization they belong to. A customer should be able to receive notifications and set their
            preferences for receiving notifications from that business.
\end{itemize}

\subsection{Functional requirements}
\label{freq}
Functional requirements define the specific actions, tasks, and behaviors that the product
must be able to perform in order to meet the needs of its end-users. These requirements
form the foundation of the system's functionality.

\noindent The functional requirements we captured for each actor in are outlined below.

\paragraph{Authentication and Profile settings}
\label{common-req}
\begin{itemize}
      \item \textbf{Sign in:} A registered user should be able to access the system by providing
            valid credentials.
      \item \textbf{Edit profile settings:} A logged in user should be able to edit his profile settings.
      \item \textbf{View statistics:} A logged in user should be able to view notification activity metrics
            on his dashboard.
\end{itemize}
\raggedbottom


\paragraph{Administrator requirements}
\label{admin-req}
\begin{itemize}
      \item \textbf{Manage agents:} An administrator should be able to add new agents, update,
            delete, desactivate accounts and reset passwords for existing agents.
      \item \textbf{Manage channels:} An administrator should be able to create new notification channels,
            update, delete, configure service providers for existing channels.
      \item \textbf{Manage topics:} An administrator should be able to create new notification topics,
            update, delete and configure topic's priority for existing ones.
\end{itemize}


\paragraph{Agent requirements}
\label{agent-req}
\begin{itemize}
      \item \textbf{Manage templates:} An agent should be able to create new notification templates, update and
            delete existing ones.
      \item \textbf{Manage triggers:} An agent should be able to create new notification triggers, configure
            the target audience the scheduling, update, change status and delete existing triggers.
      \item \textbf{Manage audiences:} An agent should be able create new segments of users based on a
            criteria, update and delete existing ones.
      \item \textbf{View logs:} An agent should be able to view logs of sent notifications and their statuses.
\end{itemize}

\paragraph{Client requirements}
\label{client-req}
\begin{itemize}
      \item \textbf{Manage notification preference:} A client should be able to edit his notification preferences,
            channels and frequency of receiving notifications.
      \item \textbf{View notification history:} A client should be able to checkout a history of his received
            notifications (for in-app notifications).
\end{itemize}

\subsection{Non-Functional requirements}
\label{nfr}
When designing a notification system, various technical requirements need to be considered to ensure
its effectiveness, reliability, and scalability. Here are the key requirements that should be addressed:

\begin{itemize}
      \item \textbf{Security:} The system shall enforce secure communication protocols, such as \acrshort{https},
            to protect sensitive data during transmissionn, also data and preferences stored in the system shall be securely
            encrypted to prevent unauthorized access or data breaches.
      \item \textbf{Real-time:} The system shall deliver notifications in real-time or near real-time
            to ensure timely communication, messages and notifications should be delivered with minimal delay for high
            priority topics.
      \item \textbf{Scalability:} The system should be designed to handle a high volume of concurrent users
            and notifications without compromising performance and the system architecture should be scalable, allowing for
            horizontal scaling by adding more servers or utilizing cloud-based infrastructure as the user base grows.
      \item \textbf{Customizability:} The system should provide flexibility and customizability to meet
            the specific branding and user experience requirements of different organizations. Also the system should
            allow customization of user preferences to provide a personalized experience.
\end{itemize}

\section{Scrum implementation overview}
\label{spec}
This section provides an overview of the Scrum implementation in our project It includes a global use case diagram, showcasing the system's
high-level functionalities, followed by the presentation of the product backlog and the planning
of the sprints.

\subsection{Global use case diagram}
Using \acrshort{uml} use case diagrams to model the requirements allows for a visual representation
of the interactions between actors and the system, providing a clear and concise way to specify
the functionalities and behaviors expected from the product.

The figure \ref{g-usecase} illustrates the global use case diagram we modeled for our notification system: \\

\begin{figure}[hbt!]
      \centering
      \includesvg[width=0.8\textwidth]{diagrams/usecase/global}
      \caption{Notification Center global use case diagram}
      \label{g-usecase}
\end{figure}

\subsection{Product backlog}
The Product Backlog serves as a dynamic and living artifact that captures and organizes the
ever-evolving list of features, functionalities, and enha   ncements desired for a software product.

\begin{itemize}
      \item \textbf{Epic:} Is a large body of work that can be broken down into a number of smaller stories.
      \item \textbf{User story:} Is an informal, general explanation of a software feature written from the
            perspective of the end user or customer, in the form of: \\ “As a [persona], I [want to], [so that].” \\
            % \item \textbf{Estimation:} An estimate of the overall effort required to fully implement a product
            %       backlog item or any other piece of work, in our case we used the number of working hours. \\
\end{itemize}

\begin{longtable}{ | m{0.18\textwidth}  | m{0.77\textwidth} | }
      \hline
      \textbf{Epic}                                           & \textbf{User story}                                                                                                                                                   \\
      \hline
      \endfirsthead
      \hline
      \textbf{Epic}                                           & \textbf{User story}                                                                                                                                                   \\
      \hline
      \endhead
      \hline
      \endfoot
      \endlastfoot
      \multirow[t]{2}{5em}{Authentication}                    & As a new user, I want to be able to create an account so that I can use the notification center.                                                                      \\
      \cline{2-2}
                                                              & As a registered user, I want to be able to log into my account securely using my email and password.                                                                  \\
      \hline
      \multirow[t]{4}{5em}{Agents management}                 & As an administrator, I want to be able to create agents so that I can add them to the notification center.                                                            \\
      \cline{2-2}
                                                              & As an administrator, I want to be able to list agents so that I can view all registered agents.                                                                       \\
      \cline{2-2}
                                                              & As an administrator, I want to be able to edit agents so that I can modify their information.                                                                         \\
      \cline{2-2}
                                                              & As an administrator, I want to be able to delete agents so that I can get rid of no longer needed agents.                                                             \\
      \hline
      \multirow[t]{4}{5em}{Users management}                  & As an administrator/agent, I want to be able to create users so that I can send them notifications.                                                                   \\
      \cline{2-2}
                                                              & As an administrator/agent, I want to be able to list users so that I can view all created users.                                                                      \\
      \cline{2-2}
                                                              & As an administrator/agent, I want to be able to edit users so that I can modify their information.                                                                    \\
      \cline{2-2}
                                                              & As an administrator/agent, I want to be able to delete users so that I can get rid of no longer needed users.                                                         \\
      \hline
      \multirow[t]{4}{5em}{Audience management}               & As an administrator/agent, I want to be able to create an audience so that I can target specific individuals based on a criteria.                                     \\
      \cline{2-2}
                                                              & As an administrator/agent, I want to be able to list audiences so that I can view all created segments.                                                               \\
      \cline{2-2}
                                                              & As an administrator/agent, I want to be able to edit an audience so that I can change selection criteria and segment configurations.                                  \\
      \cline{2-2}
                                                              & As an administrator/agent, I want to be able to delete a group of users so that I can get rid of no longer needed groups..                                            \\
      \hline
      \multirow[t]{4}{5em}{Notification channels management}  & As an administrator/agent, I want to be able to create notification channels so that I can send notifications through these channels.                                 \\
      \cline{2-2}
                                                              & As an administrator/agent, I want to be able to list notification channels so that I can view all created channels.                                                   \\
      \cline{2-2}
                                                              & As an administrator, I want to be able to edit notification channels so that I can modify or update their configurations.                                             \\
      \cline{2-2}
                                                              & As an administrator/agent, I want to be able to delete notification channels so that I can get rid of no longer used channels.                                        \\
      \hline
      \multirow[t]{4}{5em}{Notification templates management} & As an agent, I want to be able to add notification templates so that I can send notifications based on that template.                                                 \\
      \cline{2-2}
                                                              & As an agent, I want to be able to list notification templates so that I can view all created templates.                                                               \\
      \cline{2-2}
                                                              & As an agent, I want to be able to edit notification templates so that I can keep them up to date.                                                                     \\
      \cline{2-2}
                                                              & As an agent, I want to be able to delete templates so that I can get rid of no longer used templates.                                                                 \\
      \hline
      Notification preferences management                     & As a user, I want to be able to set my notification preferences, so that I can receive notifications from the channels I want.                                        \\
      \hline
      \multirow[t]{4}{5em}{Notification triggers management}  & As an agent, I want to be able to create triggers for notifications so that I can schedule notifications to be sent automatically.                                    \\
      \cline{2-2}
                                                              & As an agent, I want to be able to list triggers for notifications so that I can view all created triggers.                                                            \\
      \cline{2-2}
                                                              & As an agent, I want to be able to edit notifications triggers so that I can modify or update its configurations.                                                      \\
      \cline{2-2}
                                                              & As an agent, I want to be able to delete notification triggers so that I can get rid of outdated and no longer used triggers.                                         \\
      \hline
      \multirow[t]{4}{5em}{Notification history}              & As a user, I want to be able to list notification history so that I can review my received notifications whenever I want.                                             \\
      \cline{2-2}
                                                              & As an administrator/agent, I want to be able to list sent notification logs so that I can review all sent notifications.                                              \\
      \hline
      Dashboard                                               & As an administrator/agent I want to be able to view metrics on my dashboard so that I can get an overview on important statistics related to notification activities. \\
      \hline
      \caption{Product backlog}
\end{longtable}

\subsection{Releases and sprints planning}
A release refers to the deployment of a specific version or update of a software product. It involves meticulous planning
and coordination to ensure successful delivery.

In the following table, we present the detailed planning of the releases, outlining the sprints included in each release,
and the epics included in each sprint. \\

\begin{table}[hbt!]
      \begin{tabular}{ | m{0.25\textwidth} | m{0.25\textwidth} | m{0.42\textwidth} | }
            \hline
            \textbf{Release}             & \textbf{Sprints}            & \textbf{Epics}                      \\
            \hline
            \multirow{2}{5em}{Release 1}
                                         & \multirow{3}{5em}{Sprint 1} & Authentication                      \\
            \cline{3-3}
                                         &                             & Agents management                   \\
            \cline{3-3}
                                         &                             & Users management                    \\
            \cline{2-3}

                                         & \multirow{2}{5em}{Sprint 2} & Audiences management                \\
            \cline{3-3}
                                         &                             & Notification channels management    \\
            \hline
            \multirow{2}{5em}{Release 2} & \multirow{2}{5em}{Sprint 3} & Notification templates management   \\
            \cline{3-3}
                                         &                             & Notification preferences management \\
            \cline{2-3}
                                         & \multirow{3}{5em}{Sprint 4} & Notification triggers management    \\
            \cline{3-3}
                                         &                             & Notification history                \\
            \cline{3-3}
                                         &                             & Dashboard                           \\
            \hline
      \end{tabular}
      \caption{Releases and sprints planning}
      \label{tab:planning}
\end{table}

\section{Development infrastructure}
In this section, we will discuss the development infrastructure established for the successful execution
of the project. The primary focus will be on the software architecture. Additionally, we will elaborate
on the database choice and the curated set of tools and frameworks that were employed to support and
streamline the development workflow.


\subsection{Software architecture}
To implement our notification center, we will base our work on a client-server architecture.
In this approach, the client, representing the user interface, interacts with the server, which houses
the application's core logic and data. This separation of concerns allows for centralized management
of data and business logic while catering to various clients.

One of the extensions to the mentioned architecture, and the one we will adopt is
the \textbf{three-tier monolithic architecture}, where all the application modules and components
are tightly integrated into a single codebase. This decision was based on several factors such as
the project's scope, timeline, and the team's familiarity with monolithic architectures.
Furthermore, for the envisioned requirements, a monolithic design offered simplicity and ease
of development and deployment to quickly get the application started.

\noindent The figure \ref{monolithic} shows the separation of the three tiers in the monolithic architecture : \\

\begin{figure}[hbt!]
      \centering
      \includesvg[width=0.85\textwidth]{app/monolithic}
      \caption{Monolithic three-tier architecture}
      \label{monolithic}
\end{figure}

\paragraph{Presentation tier:}
The presentation tier is the user interface and communication layer of the application. Its main purpose
is to display information to and collect information from the user. This top-level tier can run on a web
browser, as desktop application, or a graphical user interface.

\paragraph{Application tier:}
In this tier, information collected in the presentation tier is processed, sometimes against other
information in the data tier, using business logic, a specific set of business rules. The application
tier can also add, delete or modify data in the data tier.

\paragraph{Data tier:}
The data tier, sometimes called database tier, data access tier or back-end, is where the information
processed by the application is stored and managed. This can be a relational database management system
or a NoSQL Database server.

The user interface, business logic, and the database all reside on different machines and, thus, have
different tiers. They are physically separated.

% TODO: Illustraion if needed for components

% A thin client is a client that holds just the user interface of the application. It contains no business logic of any sort. For every action, the client sends a request to the backend server, just like in a three-tier application.

\subsection{Database}
Selecting the appropriate database is a pivotal decision in our system design. After careful consideration,
we've chosen to employ a relational database, specifically PostgreSQL. This choice is driven by the
following criteria:

\begin{itemize}
      \item \textbf{Structured Data:} We need to store notification channels and templates, user segments,
            and scheduling details in structured tables, these entities share relationships that
            interconnect them.
      \item \textbf{ACID Compliance:} We need to ensure data integrity and consistency, as it's critical
            for reliable notification delivery and management.
      \item \textbf{Query Flexibility:} We need to leverage SQL queries to effectively retrieve and manipulate
            Data, enabling comprehensive reporting and analysis.
\end{itemize}

PostgreSQL is an open source object-relational database system that has a strong reputation for its
reliability, flexibility, and support of open technical standards. PostgreSQL comes with many features
aimed to help developers build applications and help managing higher data loads. In addition to being
free and open source, PostgreSQL is highly extensible.

% \subsection{Technology Stack and Framework Selection}
% In this part, we will delve into the technology stack and frameworks adopted for our project.
% This includes considerations for both backend and frontend components. By examining these choices,
% we gain a clear understanding of the tools driving the development of our project.

\subsection{Server-side technology}
This section delves into the chosen technology for the backend part of our solution and the
internal architectural pattern.

\subsubsection{Spring Boot framework}
Spring Boot emerged as the optimal backend technology for our project.
Spring Boot is built upon the robust Spring framework, makes developing production-grade Spring based
web application and microservices faster and easier through three core capabilities:

\begin{itemize}
      \item \textbf{Auto Configuration:} Spring Boot comes with built-in autoconfiguration capabilities,
            it automatically configures both the underlying Spring Framework and third-party packages based
            on the provided settings.
      \item \textbf{Opinionated approach:}  Spring Boot chooses which packages to install and which default
            values to use,rather than requiring the developer to make all those decisions on their own and set
            up everything manually.
      \item \textbf{Standalone applications:} Spring Boot helps developers create standalone applications
            that run on their own, without relying on an external web server, by embedding a web server such as
            Tomcat into the application during the initialization process.
\end{itemize}

\subsubsection{Spring boot flow architecture}
Spring Boot uses a hierarchical architecture in which each layer communicates with the layer immediately
below or above it as show in the following figure \ref{layers}

\begin{figure}[hbt!]
      \centering
      \includesvg[width=0.7\textwidth]{app/spring-boot-layers}
      \caption{Spring Boot application layers}
      \label{layers}
\end{figure}

Spring Boot integrates almost all of the features and modules of the Spring framework: like Spring MVC,
Spring Core, Spring Data \& JPA, etc. Spring Boot follows nearly the same architectural pattern as
Spring MVC, except for one thing: there is no need for \acrfull{dao} and \acrshort{dao} Implementation
classes in Spring boot because as we mentioned in figure \ref{layers} its architecture has a data access
layer and performs \acrshort{crud} operations.

% Spring flow architecture illustration
\begin{figure}[hbt!]
      \centering
      \includesvg[width=0.85\textwidth]{app/spring-flow}
      \caption{Spring Boot flow architecture}
      \label{flow}
\end{figure}


\subsection{Client-side technology}
This section illustrates the chosen technology for the client side of our solution and the adopted
internal architectural pattern.

\subsubsection{Angular framework}
For the user facing part of our solution, we will select the Angular frontend framework.
Angular, developed and maintained by Google, is a development platform, built on TypeScript and
includes:
\begin{itemize}
      \item A component-based framework for building scalable web applications.
      \item A collection of well-integrated libraries that cover a wide variety of features,
            including routing, forms management, client-server communication, etc.
      \item A suite of developer tools to help develop, build, test, and update code. \cite{angular}
\end{itemize}
\raggedbottom

\subsubsection{Angular architectural pattern}

Angular follows a component-based architectural pattern that aligns closely with the
\acrfull{mvvm} pattern, a design paradigm that separates concerns in frontend
development. While Angular's terminologies don't exactly match \acrshort{mvvm},
the concepts map as follows: \\

\begin{figure}[hbt!]
      \centering
      \includesvg[width=0.85\textwidth]{app/mvvm}
      \caption{\acrshort{mvvm} architectural pattern}
      \label{mvvm}
\end{figure}

\paragraph{Model:} Corresponds to business logic encapsulated within services and components.
Services encapsulate data retrieval and manipulation, and act as the bridge between
the application and external data sources.

\paragraph{View:} Corresponds to the HTML templates in Angular. Templates define the structure and
appearance of the user interface. Angular's binding mechanisms (property binding, event binding,
and two-way binding) facilitate the synchronization between the model (data) and the view (UI).

\paragraph{ViewModel:} Is represented by the component class. The component class contains
the presentation logic, handling user interactions, processing data, and managing the application's state.
It orchestrates the communication between the model and the view, ensuring that changes in one are
reflected appropriately in the other.

\subsection{JHipster Platform}
In our quest to identify effective tools for accelerating the development of an enterprise-level solution
while minimizing the burdens of boilerplate code and other repetitive tasks, we conducted a research.
Our objective was to pinpoint a solution that not only expedites project initiation but also empowers
our team to concentrate on the core application logic.

We have chosen JHipster as the foundation for our project development. JHipster is a development
platform to quickly generate, develop, and deploy modern web applications and microservice
architectures \cite{jhipster}.

\noindent The value proposition that JHipster provides is reflected in:

\begin{itemize}
      \item The creation of fully configured applications for both the front and the back ends.
            In addition to the generation of code according to best practices and coding standards,
            ensuring a high level of code quality and consistency throughout the project.
      \item JHipster's integrated DevOps and \acrshort{cicd} capabilities provide a seamless pathway to automate
            testing, deployment, and delivery processes.
\end{itemize}

\noindent In conjunction with JHipster, we employed various complementary software tools to enhance
the development process. (see Appendix \ref{appendix:tools})

\phantomsection
\section*{Summary}
\addcontentsline{toc}{section}{Summary}
In this chapter we laid the groundwork for the project by comprehensively gathering and analyzing
the requirements. By identifying end-users, defining functional and non-functional requirements,
and creating a clear specification through use case diagrams, elaborating the product backlog, planning
sprints, specifying the application's architecture and the requisite development infrastructure, we have
set the stage for the subsequent phases of development.

The insights gained from this chapter will prove invaluable in ensuring the successful implementation
of the project and the satisfaction of the end-users. In the following chapter, we will start executing
our project providing the practical realization of the initial release.
